package cmd

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	"tunnox-core/internal/client"
	"tunnox-core/internal/client/cli"

	"github.com/spf13/cobra"
)

// codeCmd 连接码管理命令组
var codeCmd = &cobra.Command{
	Use:   "code",
	Short: "Manage connection codes",
	Long: `Manage connection codes for tunnel establishment.

Connection codes are one-time codes that simplify tunnel setup between clients.
A TargetClient generates a code, and a ListenClient uses it to create a tunnel.

Commands:
  generate    Generate a new connection code
  use         Use a connection code to create a tunnel
  list        List all your connection codes
  revoke      Revoke a connection code`,
}

// codeGenerateCmd 生成连接码
var codeGenerateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate a new connection code",
	Long: `Generate a new connection code for tunnel establishment.

The generated code can be shared with others to allow them to create a tunnel
to your local service.

Example:
  tunnox code generate
  tunnox code generate --target tcp://192.168.1.10:8080`,
	Run: runCodeGenerate,
}

// codeUseCmd 使用连接码
var codeUseCmd = &cobra.Command{
	Use:   "use [code]",
	Short: "Use a connection code to create a tunnel",
	Long: `Use a connection code to create a tunnel mapping.

After using a code, a local listener will be created that forwards traffic
to the remote target specified by the code generator.

Example:
  tunnox code use ABC123
  tunnox code use ABC123 --listen 127.0.0.1:8888`,
	Args: cobra.MaximumNArgs(1),
	Run:  runCodeUse,
}

// codeListCmd 列出连接码
var codeListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all your connection codes",
	Long: `List all connection codes generated by this client.

Shows both active and expired codes with their status.

Example:
  tunnox code list`,
	Run: runCodeList,
}

// codeRevokeCmd 撤销连接码
var codeRevokeCmd = &cobra.Command{
	Use:   "revoke [code]",
	Short: "Revoke a connection code",
	Long: `Revoke a connection code to prevent it from being used.

Example:
  tunnox code revoke ABC123`,
	Args: cobra.ExactArgs(1),
	Run:  runCodeRevoke,
}

// 命令标志
var (
	codeTarget        string
	codeListen        string
	codeActivationTTL int
	codeMappingTTL    int
)

func init() {
	// 添加子命令
	codeCmd.AddCommand(codeGenerateCmd)
	codeCmd.AddCommand(codeUseCmd)
	codeCmd.AddCommand(codeListCmd)
	codeCmd.AddCommand(codeRevokeCmd)

	// generate 命令标志
	codeGenerateCmd.Flags().StringVar(&codeTarget, "target", "", "Target address (e.g., tcp://192.168.1.10:8080)")
	codeGenerateCmd.Flags().IntVar(&codeActivationTTL, "activation-ttl", 10, "Activation TTL in minutes")
	codeGenerateCmd.Flags().IntVar(&codeMappingTTL, "mapping-ttl", 7, "Mapping TTL in days")

	// use 命令标志
	codeUseCmd.Flags().StringVar(&codeListen, "listen", "", "Local listen address (e.g., 127.0.0.1:8888)")
}

func runCodeGenerate(cmd *cobra.Command, args []string) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// 设置信号处理
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		select {
		case <-sigChan:
			cancel()
		case <-ctx.Done():
		}
	}()

	output := cli.NewOutput(false)
	output.Header("Generate Connection Code")

	// 确保连接
	if err := ensureConnected(ctx); err != nil {
		output.Error("Connection failed: %v", err)
		os.Exit(1)
	}

	var targetAddress string

	if codeTarget != "" {
		targetAddress = codeTarget
	} else {
		// 交互式选择协议
		fmt.Println()
		protocolOptions := []string{"TCP", "SOCKS5", "Back"}
		protocolIndex, err := cli.PromptSelect("Select Protocol:", protocolOptions)
		if err != nil || protocolIndex < 0 || protocolIndex == len(protocolOptions)-1 {
			return
		}

		selectedProtocol := strings.ToLower(protocolOptions[protocolIndex])

		if selectedProtocol == "socks5" {
			targetAddress = "socks5://0.0.0.0:0"
			output.Info("SOCKS5 proxy selected (dynamic targets)")
		} else {
			// 输入目标地址
			fmt.Println()
			for {
				addr, err := promptInput(fmt.Sprintf("Target Address (e.g., 192.168.1.10:8080): "))
				if err != nil {
					return
				}

				addr = strings.TrimSpace(addr)
				if addr == "" {
					output.Error("Target address cannot be empty")
					continue
				}

				// 验证地址格式
				if !strings.Contains(addr, ":") {
					output.Error("Invalid address format: missing port")
					continue
				}

				// 验证端口
				parts := strings.Split(addr, ":")
				if len(parts) < 2 {
					output.Error("Invalid address format")
					continue
				}

				port, err := strconv.Atoi(parts[len(parts)-1])
				if err != nil || port < 1 || port > 65535 {
					output.Error("Invalid port number")
					continue
				}

				targetAddress = fmt.Sprintf("%s://%s", selectedProtocol, addr)
				break
			}
		}
	}

	// 生成连接码
	fmt.Println()
	output.Info("Generating connection code...")

	resp, err := tunnoxClient.GenerateConnectionCode(&client.GenerateConnectionCodeRequest{
		TargetAddress: targetAddress,
		ActivationTTL: codeActivationTTL * 60,
		MappingTTL:    codeMappingTTL * 24 * 3600,
	})

	if err != nil {
		output.Error("Failed to generate code: %v", err)
		os.Exit(1)
	}

	// 显示结果
	fmt.Println()
	output.Success("Connection Code Generated!")
	output.Separator()
	output.KeyValue("Code", cli.ColorBold(resp.Code))
	output.KeyValue("Target", resp.TargetAddress)
	output.KeyValue("Expires At", resp.ExpiresAt)
	output.Separator()
	fmt.Println()
	output.Info("Share this code with the ListenClient to create a tunnel mapping.")
	output.Info("They can use: tunnox code use %s", resp.Code)
	fmt.Println()
}

func runCodeUse(cmd *cobra.Command, args []string) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// 设置信号处理
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		select {
		case <-sigChan:
			cancel()
		case <-ctx.Done():
		}
	}()

	output := cli.NewOutput(false)

	// 获取连接码
	var code string
	if len(args) > 0 {
		code = args[0]
	} else {
		output.Header("Use Connection Code")
		fmt.Println()
		var err error
		code, err = promptInput("Enter connection code: ")
		if err != nil {
			return
		}
		code = strings.TrimSpace(code)
	}

	if code == "" {
		output.Error("Connection code is required")
		os.Exit(1)
	}

	// 确保连接
	if err := ensureConnected(ctx); err != nil {
		output.Error("Connection failed: %v", err)
		os.Exit(1)
	}

	// 获取监听地址
	var listenAddr string
	if codeListen != "" {
		listenAddr = codeListen
	} else {
		fmt.Println()
		for {
			addr, err := promptInput("Local Listen Address (e.g., 127.0.0.1:8888): ")
			if err != nil {
				return
			}

			addr = strings.TrimSpace(addr)
			if addr == "" {
				output.Error("Listen address cannot be empty")
				continue
			}

			// 如果只输入了端口号
			if !strings.Contains(addr, ":") {
				port, err := strconv.Atoi(addr)
				if err != nil || port < 1 || port > 65535 {
					output.Error("Invalid port number")
					continue
				}
				listenAddr = fmt.Sprintf("127.0.0.1:%d", port)
			} else {
				listenAddr = addr
			}
			break
		}
	}

	// 激活连接码
	fmt.Println()
	output.Info("Activating connection code...")

	resp, err := tunnoxClient.ActivateConnectionCode(&client.ActivateConnectionCodeRequest{
		Code:          code,
		ListenAddress: listenAddr,
	})

	if err != nil {
		output.Error("Failed to activate code: %v", err)
		os.Exit(1)
	}

	// 显示结果
	fmt.Println()
	output.Success("Connection Code Activated!")
	output.Separator()
	output.KeyValue("Mapping ID", resp.MappingID)
	output.KeyValue("Target", resp.TargetAddress)
	output.KeyValue("Listen", resp.ListenAddress)
	output.KeyValue("Expires At", resp.ExpiresAt)
	output.Separator()
	fmt.Println()
	output.Info("Tunnel mapping created! You can now connect to %s", resp.ListenAddress)
	fmt.Println()

	// 如果指定了交互模式，进入 CLI
	if interactive {
		runInteractiveCLI()
	}
}

func runCodeList(cmd *cobra.Command, args []string) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	output := cli.NewOutput(false)
	output.Header("Connection Codes")

	// 确保连接
	if err := ensureConnected(ctx); err != nil {
		output.Error("Connection failed: %v", err)
		os.Exit(1)
	}

	resp, err := tunnoxClient.ListConnectionCodes()
	if err != nil {
		output.Error("Failed to list codes: %v", err)
		os.Exit(1)
	}

	if len(resp.Codes) == 0 {
		output.Info("No connection codes found.")
		return
	}

	// 创建表格
	table := cli.NewTable("CODE", "TARGET", "STATUS", "ACTIVATED BY", "EXPIRES AT")

	for _, code := range resp.Codes {
		if code.Status == "expired" && !code.Activated {
			continue
		}

		var status string
		if code.Activated {
			status = cli.ColorSuccess("activated")
		} else if code.Status == "available" || code.Status == "active" {
			status = "available"
		} else if code.Status == "revoked" {
			status = cli.ColorWarning("revoked")
		} else {
			status = code.Status
		}

		activatedBy := "-"
		if code.Activated && code.ActivatedBy != nil {
			activatedBy = fmt.Sprintf("client-%d", *code.ActivatedBy)
		}

		table.AddRow(
			cli.Truncate(code.Code, 18),
			cli.Truncate(code.TargetAddress, 35),
			status,
			cli.Truncate(activatedBy, 15),
			cli.FormatTime(code.ExpiresAt),
		)
	}

	table.Render()

	fmt.Println()
	output.Info("Total: %d codes", resp.Total)
	fmt.Println()
}

func runCodeRevoke(cmd *cobra.Command, args []string) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	output := cli.NewOutput(false)

	code := args[0]
	output.Header(fmt.Sprintf("Revoke Connection Code: %s", code))

	// 确保连接
	if err := ensureConnected(ctx); err != nil {
		output.Error("Connection failed: %v", err)
		os.Exit(1)
	}

	// TODO: 实现撤销连接码的 API
	output.Warning("Code revocation is not yet implemented")
	output.Info("The code will expire automatically based on its TTL")
	fmt.Println()
}
