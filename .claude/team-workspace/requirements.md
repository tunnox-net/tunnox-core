# HTTP 域名映射持久化存储重构 - 需求规格文档

**文档版本**: v1.0
**创建日期**: 2026-01-01
**产品经理**: AI 产品经理
**项目代号**: HTTP-DOMAIN-PERSISTENCE

---

## 1. 问题背景

### 1.1 当前架构分析

当前 HTTP 域名映射使用两套独立的内存存储：

1. **DomainRegistry** (`internal/httpservice/domain_registry.go`)
   - 用于 HTTP 服务模块的域名查找
   - 基于 `sync.RWMutex` 的纯内存实现
   - 支持 `Rebuild()` 方法从外部数据源重建

2. **InMemoryDomainRegistry** (`internal/app/server/http_domain_command_handlers.go`)
   - 用于命令处理器的域名注册
   - 每个 Server 实例独立创建
   - 无持久化能力

### 1.2 集群环境下的严重问题

```
┌─────────────────────────────────────────────────────────────────┐
│                    Kubernetes 集群                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│   │   Pod A     │    │   Pod B     │    │   Pod C     │        │
│   │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────────┐ │        │
│   │ │Registry │ │    │ │Registry │ │    │ │Registry │ │        │
│   │ │ app.xyz │ │    │ │  (空)   │ │    │ │  (空)   │ │        │
│   │ └─────────┘ │    │ └─────────┘ │    │ └─────────┘ │        │
│   └─────────────┘    └─────────────┘    └─────────────┘        │
│          ▲                  ▲                  ▲                │
│          │                  │                  │                │
│   ┌──────┴──────────────────┴──────────────────┴──────┐        │
│   │              LoadBalancer (轮询)                   │        │
│   └──────────────────────────────────────────────────┘        │
│                           ▲                                    │
│                           │                                    │
└───────────────────────────┼────────────────────────────────────┘
                            │
                      用户访问 app.tunnox.net

问题：
1. 用户在 Pod A 创建域名映射 app.tunnox.net
2. HTTP 请求被 LB 路由到 Pod B → 404（映射不存在）
3. Pod A 重启 → 映射丢失（无持久化）
```

### 1.3 影响范围

| 影响场景 | 严重程度 | 用户影响 |
|---------|---------|---------|
| 集群部署 HTTP 代理 | **P0 致命** | 随机 404，功能不可用 |
| 单 Pod 重启恢复 | **P0 致命** | 域名映射全部丢失 |
| 滚动更新部署 | **P0 致命** | 更新期间服务中断 |
| 多用户并发创建 | **P1 严重** | 可能创建冲突域名 |

---

## 2. 用户场景分析

### 2.1 目标用户画像

| 用户类型 | 使用场景 | 核心诉求 |
|---------|---------|---------|
| **个人开发者** | 本地开发服务临时暴露给外网 | 简单易用、免配置 |
| **小团队** | 内部服务共享、Demo 演示 | 稳定可靠、低成本 |
| **企业用户** | 生产环境 Web 服务发布 | 高可用、高性能 |
| **SaaS 提供商** | 多租户域名分配 | 可扩展、安全隔离 |

### 2.2 核心使用场景

#### 场景 1：开发测试环境（单节点）
```
用户: 开发者 Alice
目标: 将本地 localhost:3000 的 React 应用暴露为 myapp.tunnox.net

流程:
1. Alice 运行 Tunnox 客户端
2. 创建 HTTP 域名映射: myapp.tunnox.net → localhost:3000
3. 分享链接给测试同事
4. 同事通过 myapp.tunnox.net 访问 Alice 的本地服务

当前问题: 无
预期: 正常工作
```

#### 场景 2：生产环境集群（多节点）
```
用户: 企业用户 Bob
目标: 将内网 Web 服务 192.168.1.100:8080 发布为 api.example.com

流程:
1. Bob 的客户端连接到集群中的 Pod A
2. 创建 HTTP 域名映射: api.example.com → 192.168.1.100:8080
3. 外部用户访问 api.example.com

当前问题:
- 请求可能路由到 Pod B/C，返回 404
- Pod A 重启后映射丢失

预期:
- 任何 Pod 都能正确路由请求
- 映射持久化，重启不丢失
```

#### 场景 3：滚动更新部署
```
场景: K8s 滚动更新 Tunnox Server

流程:
1. 10 个用户创建了域名映射
2. K8s 开始滚动更新
3. Pod 逐个重建

当前问题:
- 每个旧 Pod 销毁时，其上的映射丢失
- 新 Pod 启动时没有历史映射

预期:
- 新 Pod 启动时自动恢复所有映射
- 更新过程对用户透明
```

#### 场景 4：多租户域名管理
```
用户: SaaS 平台运营商
目标: 为每个租户分配独立子域名

流程:
1. 租户 A 分配 tenant-a.saas.example.com
2. 租户 B 分配 tenant-b.saas.example.com
3. 每个租户映射到独立的内网服务

当前问题:
- 无法防止域名冲突（两个 Pod 可能同时分配同一域名）
- 无法查询全局域名使用情况

预期:
- 全局唯一性检查
- 支持域名配额管理
```

### 2.3 当前痛点汇总

| 痛点 | 影响用户 | 业务影响 |
|------|---------|---------|
| **集群不可用** | 所有生产用户 | HTTP 代理功能无法使用 |
| **数据丢失** | 所有用户 | 需要重新配置，中断服务 |
| **无一致性保证** | 多租户用户 | 域名冲突、数据不一致 |
| **无法监控** | 运维人员 | 无法获取全局域名状态 |
| **无法审计** | 企业用户 | 合规需求无法满足 |

---

## 3. 核心需求

### 3.1 功能需求

#### FR-1: 持久化存储（P0）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-1.1 | 域名映射数据必须持久化到可靠存储 | P0 |
| FR-1.2 | 支持 Redis 作为主要持久化后端 | P0 |
| FR-1.3 | 兼容现有 HybridStorage 分层架构 | P0 |
| FR-1.4 | Pod 重启后自动恢复域名映射 | P0 |

**数据模型设计**:
```go
// HTTPDomainMapping 完整数据模型
type HTTPDomainMapping struct {
    // === 标识字段 ===
    MappingID   string    // 映射唯一 ID，格式: hdm_<ulid>

    // === 域名信息 ===
    Subdomain   string    // 子域名部分，如 "myapp"
    BaseDomain  string    // 基础域名，如 "tunnox.net"
    FullDomain  string    // 完整域名，如 "myapp.tunnox.net"（索引）

    // === 目标信息 ===
    TargetClientID int64  // 目标客户端 ID
    TargetHost     string // 目标主机
    TargetPort     int    // 目标端口
    TargetScheme   string // 目标协议 (http/https)

    // === 所有权信息 ===
    OwnerUserID    int64  // 所有者用户 ID（可选，匿名用户为 0）
    CreatorNodeID  string // 创建该映射的节点 ID

    // === 状态与生命周期 ===
    Status      string     // active, inactive, expired, revoked
    CreatedAt   time.Time  // 创建时间
    UpdatedAt   time.Time  // 更新时间
    ExpiresAt   *time.Time // 过期时间（可选）
    LastAccessAt time.Time // 最后访问时间（用于清理）

    // === 配置选项 ===
    Description   string            // 用户描述
    CustomHeaders map[string]string // 自定义请求头（可选）
    EnableHTTPS   bool              // 是否启用 HTTPS

    // === 统计信息 ===
    AccessCount   int64 // 访问次数
    BytesIn       int64 // 入站流量
    BytesOut      int64 // 出站流量
}
```

**存储键设计**:
```
# Redis 键设计
tunnox:http_domain:mapping:{mapping_id}     → HTTPDomainMapping JSON
tunnox:http_domain:index:domain:{full_domain} → mapping_id（域名→ID 索引）
tunnox:http_domain:index:client:{client_id}   → SET<mapping_id>（客户端→映射集合）
tunnox:http_domain:index:user:{user_id}       → SET<mapping_id>（用户→映射集合）
```

#### FR-2: 缓存加速（P0）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-2.1 | 本地内存缓存高频访问的域名映射 | P0 |
| FR-2.2 | 缓存 TTL 可配置，默认 60 秒 | P0 |
| FR-2.3 | 支持缓存主动失效（映射变更时） | P0 |
| FR-2.4 | 缓存未命中时从 Redis 加载 | P0 |

**缓存架构**:
```
┌─────────────────────────────────────────────────────────────┐
│                     请求处理流程                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   HTTP 请求 (Host: myapp.tunnox.net)                        │
│         │                                                    │
│         ▼                                                    │
│   ┌─────────────┐                                           │
│   │  L1 缓存    │ ← 本地内存，TTL 60s                       │
│   │  (Memory)   │   命中率目标: >90%                        │
│   └──────┬──────┘                                           │
│          │ 未命中                                            │
│          ▼                                                    │
│   ┌─────────────┐                                           │
│   │  L2 缓存    │ ← Redis 共享缓存，TTL 300s                │
│   │  (Redis)    │   跨节点共享                               │
│   └──────┬──────┘                                           │
│          │ 未命中                                            │
│          ▼                                                    │
│   ┌─────────────┐                                           │
│   │  持久层     │ ← Redis 持久化存储                        │
│   │  (Redis)    │   数据持久化，高可靠                       │
│   └─────────────┘                                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### FR-3: 集群共享（P0）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-3.1 | 所有节点共享同一份域名映射数据 | P0 |
| FR-3.2 | 新节点启动时自动同步全量数据 | P0 |
| FR-3.3 | 映射变更实时通知所有节点 | P0 |
| FR-3.4 | 支持跨节点域名唯一性检查 | P0 |

**集群同步机制**:
```
┌─────────────────────────────────────────────────────────────┐
│                     集群同步架构                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐                │
│   │  Pod A  │    │  Pod B  │    │  Pod C  │                │
│   │         │    │         │    │         │                │
│   │ [L1缓存] │    │ [L1缓存] │    │ [L1缓存] │                │
│   └────┬────┘    └────┬────┘    └────┬────┘                │
│        │              │              │                      │
│        └──────────────┼──────────────┘                      │
│                       │                                      │
│                       ▼                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                    Redis Cluster                      │  │
│   │  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐  │  │
│   │  │ 持久化存储   │  │ Pub/Sub    │  │ 分布式锁     │  │  │
│   │  │ (Hash)      │  │ (变更通知)  │  │ (唯一性)     │  │  │
│   │  └─────────────┘  └─────────────┘  └──────────────┘  │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                              │
│   变更流程:                                                  │
│   1. Pod A 创建映射 → 写入 Redis                            │
│   2. Redis Pub/Sub 广播变更事件                             │
│   3. Pod B/C 接收事件 → 失效本地缓存                        │
│   4. 下次请求时从 Redis 重新加载                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### FR-4: 域名唯一性保证（P0）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-4.1 | 同一域名全局只能创建一次 | P0 |
| FR-4.2 | 使用 Redis 分布式锁防止并发冲突 | P0 |
| FR-4.3 | 创建失败返回明确错误（域名已被占用） | P0 |
| FR-4.4 | 支持域名过期后自动释放 | P1 |

#### FR-5: 启动恢复（P0）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-5.1 | 服务启动时从 Redis 加载全量域名索引 | P0 |
| FR-5.2 | 支持增量恢复（仅加载本节点相关映射） | P1 |
| FR-5.3 | 恢复失败不阻塞服务启动 | P0 |
| FR-5.4 | 提供健康检查 endpoint 确认恢复完成 | P1 |

#### FR-6: 管理 API（P1）

| 需求ID | 需求描述 | 优先级 |
|--------|---------|--------|
| FR-6.1 | 提供 REST API 查询全局域名列表 | P1 |
| FR-6.2 | 支持按用户/客户端过滤域名 | P1 |
| FR-6.3 | 支持管理员强制删除域名映射 | P1 |
| FR-6.4 | 提供域名使用统计 API | P2 |

### 3.2 非功能需求

#### NFR-1: 性能要求

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **域名查找延迟 (P99)** | < 1ms | L1 缓存命中 |
| **域名查找延迟 (P99)** | < 10ms | L2/Redis 查找 |
| **创建映射延迟 (P99)** | < 50ms | 包含分布式锁 |
| **缓存命中率** | > 90% | L1 本地缓存 |
| **缓存命中率** | > 99% | L1 + L2 合计 |

#### NFR-2: 可靠性要求

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **数据持久化** | 99.99% | 不丢失已创建映射 |
| **服务可用性** | 99.9% | 月度可用时间 |
| **故障恢复时间** | < 30s | 单 Pod 重启恢复 |
| **集群同步延迟** | < 100ms | 变更传播到所有节点 |

#### NFR-3: 一致性要求

| 场景 | 一致性模型 | 说明 |
|------|-----------|------|
| **域名创建** | 强一致 | 分布式锁保证唯一性 |
| **域名查找** | 最终一致 | 允许短暂缓存不一致 |
| **域名删除** | 最终一致 | 缓存失效延迟可接受 |

#### NFR-4: 可扩展性要求

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **单集群域名数** | 100,000+ | 支持大规模部署 |
| **并发创建 QPS** | 1,000+ | 峰值创建能力 |
| **并发查找 QPS** | 100,000+ | 高频请求处理 |
| **节点数量** | 1-1000 | 水平扩展能力 |

---

## 4. 验收标准

### 4.1 FR-1 持久化存储验收

| 测试场景 | 步骤 | 预期结果 |
|---------|------|---------|
| **TC-1.1: 基本持久化** | 1. 创建域名映射 `test.tunnox.net`<br>2. 重启服务<br>3. 查询该映射 | 映射数据完整保留 |
| **TC-1.2: 批量持久化** | 1. 创建 100 个域名映射<br>2. 重启服务<br>3. 验证所有映射 | 所有映射完整保留 |
| **TC-1.3: 更新持久化** | 1. 创建映射<br>2. 修改目标端口<br>3. 重启服务 | 更新后的数据保留 |
| **TC-1.4: 删除持久化** | 1. 创建映射<br>2. 删除映射<br>3. 重启服务 | 映射确实被删除 |

### 4.2 FR-2 缓存加速验收

| 测试场景 | 步骤 | 预期结果 |
|---------|------|---------|
| **TC-2.1: 缓存命中** | 1. 创建映射<br>2. 连续查询 10 次<br>3. 检查 Redis 调用次数 | 仅首次调用 Redis |
| **TC-2.2: 缓存失效** | 1. 查询映射（缓存）<br>2. 删除映射<br>3. 再次查询 | 返回 404 |
| **TC-2.3: TTL 过期** | 1. 查询映射<br>2. 等待 TTL+1s<br>3. 再次查询 | 重新从 Redis 加载 |

### 4.3 FR-3 集群共享验收

| 测试场景 | 步骤 | 预期结果 |
|---------|------|---------|
| **TC-3.1: 跨节点可见** | 1. 在 Pod A 创建映射<br>2. 在 Pod B 查询 | Pod B 能查到映射 |
| **TC-3.2: 跨节点删除** | 1. 在 Pod A 创建映射<br>2. 在 Pod B 删除<br>3. 在 Pod C 查询 | 所有 Pod 返回 404 |
| **TC-3.3: 新节点同步** | 1. 创建 10 个映射<br>2. 启动新 Pod<br>3. 新 Pod 查询所有映射 | 新 Pod 能查到所有 |
| **TC-3.4: 并发写入** | 1. 10 个 Pod 同时创建不同映射<br>2. 验证所有映射 | 全部创建成功 |

### 4.4 FR-4 唯一性保证验收

| 测试场景 | 步骤 | 预期结果 |
|---------|------|---------|
| **TC-4.1: 重复创建** | 1. 创建 `app.tunnox.net`<br>2. 再次创建相同域名 | 第二次返回错误 |
| **TC-4.2: 并发创建** | 1. 10 个 Pod 同时创建相同域名 | 仅 1 个成功，9 个失败 |
| **TC-4.3: 删后重建** | 1. 创建映射<br>2. 删除映射<br>3. 重新创建相同域名 | 重建成功 |

### 4.5 性能验收

| 测试场景 | 方法 | 验收标准 |
|---------|------|---------|
| **TC-P1: 查询延迟** | 压测 10000 次查询 | P99 < 10ms |
| **TC-P2: 创建延迟** | 压测 1000 次创建 | P99 < 100ms |
| **TC-P3: 缓存命中** | 压测后检查命中率 | > 90% |
| **TC-P4: 高并发** | 100 并发查询 | 无错误，延迟稳定 |

---

## 5. 优先级划分

### P0 - 必须实现（阻塞发布）

| 需求 | 预估工时 | 负责人 |
|------|---------|--------|
| 持久化存储架构设计 | 2d | 架构师 |
| Redis 存储层实现 | 3d | 开发 |
| 本地缓存实现 | 2d | 开发 |
| 集群共享机制 | 3d | 开发 |
| 域名唯一性保证 | 2d | 开发 |
| 启动恢复流程 | 2d | 开发 |
| 单元测试 | 2d | 开发 |
| 集成测试 | 2d | QA |

**P0 总计**: 约 18 人日

### P1 - 重要但可延期

| 需求 | 预估工时 | 说明 |
|------|---------|------|
| 管理 API | 2d | 运维需求 |
| 增量恢复优化 | 1d | 大规模优化 |
| 健康检查完善 | 1d | 运维需求 |
| 性能监控指标 | 1d | 可观测性 |

**P1 总计**: 约 5 人日

### P2 - 锦上添花

| 需求 | 预估工时 | 说明 |
|------|---------|------|
| 域名使用统计 | 2d | 商业分析 |
| 自定义请求头 | 1d | 高级功能 |
| 审计日志 | 2d | 企业合规 |

**P2 总计**: 约 5 人日

---

## 6. 技术方案概要

### 6.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    HTTP Domain Mapping 架构                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │                     接口层 (Interface)                     │ │
│   │  ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐  │ │
│   │  │ DomainProxy │  │ CommandHandler│  │ Management API  │  │ │
│   │  │   Module    │  │              │  │                 │  │ │
│   │  └──────┬──────┘  └──────┬───────┘  └────────┬────────┘  │ │
│   └─────────┼────────────────┼───────────────────┼────────────┘ │
│             │                │                   │              │
│   ┌─────────▼────────────────▼───────────────────▼────────────┐ │
│   │                   服务层 (Service)                         │ │
│   │  ┌──────────────────────────────────────────────────────┐ │ │
│   │  │            HTTPDomainMappingService                   │ │ │
│   │  │  - Create/Delete/Get/List                            │ │ │
│   │  │  - CheckAvailability                                 │ │ │
│   │  │  - RefreshCache                                      │ │ │
│   │  └──────────────────────┬───────────────────────────────┘ │ │
│   └─────────────────────────┼───────────────────────────────────┘ │
│                             │                                    │
│   ┌─────────────────────────▼───────────────────────────────────┐ │
│   │                   缓存层 (Cache)                            │ │
│   │  ┌─────────────────┐    ┌─────────────────┐               │ │
│   │  │   L1 Cache      │    │   L2 Cache      │               │ │
│   │  │   (Memory)      │    │   (Redis)       │               │ │
│   │  │   TTL: 60s      │    │   TTL: 300s     │               │ │
│   │  └────────┬────────┘    └────────┬────────┘               │ │
│   └───────────┼──────────────────────┼──────────────────────────┘ │
│               │                      │                          │
│   ┌───────────▼──────────────────────▼──────────────────────────┐ │
│   │                   持久层 (Persistence)                      │ │
│   │  ┌──────────────────────────────────────────────────────┐  │ │
│   │  │           HTTPDomainMappingRepository                 │  │ │
│   │  │  - Redis Hash: tunnox:http_domain:mapping:*          │  │ │
│   │  │  - Redis Set: tunnox:http_domain:index:*             │  │ │
│   │  │  - Redis Lock: tunnox:http_domain:lock:*             │  │ │
│   │  └──────────────────────────────────────────────────────┘  │ │
│   └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────────┐ │
│   │                   通知层 (Notification)                     │ │
│   │  ┌──────────────────────────────────────────────────────┐  │ │
│   │  │           Redis Pub/Sub                               │  │ │
│   │  │  - Channel: tunnox:http_domain:events                 │  │ │
│   │  │  - Events: created, updated, deleted                  │  │ │
│   │  └──────────────────────────────────────────────────────┘  │ │
│   └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 核心接口设计

```go
// HTTPDomainMappingService 域名映射服务接口
type HTTPDomainMappingService interface {
    // 创建映射（包含唯一性检查）
    Create(ctx context.Context, req *CreateMappingRequest) (*HTTPDomainMapping, error)

    // 删除映射
    Delete(ctx context.Context, mappingID string, clientID int64) error

    // 查找映射（域名→映射，高频调用）
    LookupByDomain(ctx context.Context, fullDomain string) (*HTTPDomainMapping, error)

    // 获取映射详情
    Get(ctx context.Context, mappingID string) (*HTTPDomainMapping, error)

    // 列出客户端的所有映射
    ListByClient(ctx context.Context, clientID int64) ([]*HTTPDomainMapping, error)

    // 检查域名可用性
    CheckAvailability(ctx context.Context, subdomain, baseDomain string) (bool, error)

    // 刷新缓存（用于变更通知）
    InvalidateCache(ctx context.Context, fullDomain string) error
}

// HTTPDomainMappingRepository 域名映射存储接口
type HTTPDomainMappingRepository interface {
    // 保存映射
    Save(ctx context.Context, mapping *HTTPDomainMapping) error

    // 获取映射
    Get(ctx context.Context, mappingID string) (*HTTPDomainMapping, error)

    // 通过域名查找
    GetByDomain(ctx context.Context, fullDomain string) (*HTTPDomainMapping, error)

    // 删除映射
    Delete(ctx context.Context, mappingID string) error

    // 列出客户端的映射
    ListByClient(ctx context.Context, clientID int64) ([]*HTTPDomainMapping, error)

    // 列出所有映射（用于启动恢复）
    ListAll(ctx context.Context) ([]*HTTPDomainMapping, error)

    // 获取分布式锁
    AcquireLock(ctx context.Context, domain string, ttl time.Duration) (bool, error)

    // 释放分布式锁
    ReleaseLock(ctx context.Context, domain string) error
}
```

### 6.3 配置项设计

```yaml
# 服务端配置
http_domain:
  # 启用 HTTP 域名代理
  enabled: true

  # 允许的基础域名
  base_domains:
    - tunnox.net
    - tunnel.example.com

  # 缓存配置
  cache:
    # L1 本地缓存
    local:
      enabled: true
      ttl: 60s
      max_size: 10000  # 最大缓存条目数

    # L2 Redis 缓存（使用共享缓存）
    shared:
      enabled: true
      ttl: 300s

  # 持久化配置（复用 storage.redis）
  persistence:
    # 键前缀
    key_prefix: "tunnox:http_domain"

  # 集群同步配置
  sync:
    # Pub/Sub 通道
    channel: "tunnox:http_domain:events"
    # 订阅缓冲区大小
    buffer_size: 1000

  # 分布式锁配置
  lock:
    ttl: 10s           # 锁超时
    retry_count: 3     # 重试次数
    retry_interval: 100ms
```

---

## 7. 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| Redis 不可用 | 低 | 高 | 本地缓存降级、Redis Sentinel/Cluster |
| 缓存不一致 | 中 | 中 | Pub/Sub 通知 + TTL 兜底 |
| 分布式锁死锁 | 低 | 高 | 锁 TTL 自动过期、看门狗续期 |
| 启动恢复过慢 | 中 | 中 | 分批加载、后台恢复 |
| 迁移数据丢失 | 低 | 高 | 双写过渡期、数据备份 |

---

## 8. 迁移方案

### 8.1 兼容性要求

- 保持现有客户端命令接口不变
- 保持现有 HTTP 代理接口不变
- 支持平滑升级，无需停机

### 8.2 迁移步骤

```
阶段 1: 双写模式（1 周）
├── 保留 InMemoryDomainRegistry
├── 新增 Redis 持久化写入
├── 读取仍走内存
└── 验证 Redis 数据正确性

阶段 2: 读写切换（1 周）
├── 读取优先走 Redis
├── 内存作为 L1 缓存
├── 监控性能指标
└── 验证集群功能

阶段 3: 清理旧代码（1 周）
├── 移除 InMemoryDomainRegistry
├── 简化代码路径
└── 更新文档
```

---

## 9. 附录

### 9.1 相关文档

- [Tunnox 架构设计 V2.2](/docs/ARCHITECTURE_DESIGN_V2.2.md)
- [存储层设计](/internal/core/storage/)
- [HTTP 服务模块](/internal/httpservice/)

### 9.2 参考实现

- [DomainRegistry 现有实现](/internal/httpservice/domain_registry.go)
- [InMemoryDomainRegistry](/internal/app/server/http_domain_command_handlers.go)
- [HybridStorage 实现](/internal/core/storage/hybrid/)

### 9.3 术语表

| 术语 | 定义 |
|------|------|
| **域名映射** | 将外部域名（如 app.tunnox.net）映射到内网服务的配置 |
| **L1 缓存** | 节点本地内存缓存，最快但不共享 |
| **L2 缓存** | Redis 共享缓存，跨节点共享 |
| **持久层** | Redis 持久化存储，保证数据不丢失 |
| **分布式锁** | 用于保证域名创建的全局唯一性 |

---

**文档审批**:

- [ ] 产品经理确认
- [ ] 架构师评审
- [ ] 开发负责人确认
- [ ] QA 负责人确认
